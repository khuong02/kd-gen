package enum

import (
	"fmt"
	"strings"

	"github.com/khuong02/kd-gen/config"

	"github.com/dave/jennifer/jen"
)

type ImportName map[string]string

type Method string
type MethodFunc func(e *Enum, name string, enumType string, values []config.EnumValue)

const (
	String    Method = "string"
	Parse     Method = "parse"
	Normalize Method = "normalize"
	JSON      Method = "json"
	SQL       Method = "sql"
)

var MethodMap = map[Method]MethodFunc{
	String: func(e *Enum, name string, enumType string, values []config.EnumValue) {
		e.String(name, enumType, values)
	},
	Parse: func(e *Enum, name string, enumType string, values []config.EnumValue) {
		e.Parse(name, enumType, values)
	},
	Normalize: func(e *Enum, name string, enumType string, values []config.EnumValue) {
		if enumType != "string" {
			// you can choose to log OR panic
			fmt.Printf("⚠️  Normalize only applies to string enums (enum %s has type %s)\n", name, enumType)
			return
		}
		e.Normalize(name)
	},
	JSON: func(e *Enum, name string, enumType string, values []config.EnumValue) {
		e.JSON(name)
	},
	SQL: func(e *Enum, name string, enumType string, values []config.EnumValue) {
		e.SQLValueScan(name)
	},
}

type Enum struct {
	f *jen.File
}

func New(packageName string) *Enum {
	return &Enum{
		f: jen.NewFile(packageName),
	}
}

func (e *Enum) HeaderComment(comment ...string) *Enum {
	e.f.HeaderComment("Code generated by enum generate; DO NOT EDIT.")
	for _, c := range comment {
		e.f.HeaderComment(c)
	}
	return e
}

func (e *Enum) ImportName(imports ...ImportName) *Enum {
	for _, imp := range imports {
		for name, alias := range imp {
			e.f.ImportName(name, alias)
		}
	}
	return e
}

func displayValue(v any, fallback any) any {
	if v == nil {
		return fallback
	}
	return v
}

func emptyValue(enumType string) interface{} {
	switch enumType {
	case "string":
		return ""
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64":
		return 0
	case "float32", "float64":
		return 0.0
	default:
		panic("unsupported enum type: " + enumType)
	}
}

func (e *Enum) Method(name, enumType string, values []config.EnumValue, methods ...string) {
	for _, m := range methods {
		if fn, ok := MethodMap[Method(strings.ToLower(m))]; ok {
			fn(e, name, enumType, values)
		} else {
			fmt.Printf("don't support method %s\n", m)
		}
	}
}

func (e *Enum) Enum(name, enumType string, values []config.EnumValue, methods []string) {
	f := e.f
	f.Type().Id(name).Id(enumType)
	e.Consts(name, enumType, values)
	e.Is(name, values)
	e.Map(name, enumType, values)
	e.Slice(name, enumType, values)
	e.Method(name, enumType, values, methods...)
}

func (e *Enum) JenFile() *jen.File {
	return e.f
}
