package enum

import (
	"fmt"
	"log/slog"
	"strings"

	"github.com/khuong02/kd-gen/config"

	"github.com/dave/jennifer/jen"
)

type ImportName map[string]string

type Method string
type MethodFunc func(e *Enum, name string, enumType string, values []config.EnumValue)

const (
	String    Method = "string"
	Parse     Method = "parse"
	Normalize Method = "normalize"
	JSON      Method = "json"
	SQL       Method = "sql"
)

var MethodDescriptions = map[Method]string{
	String:    "Generate enums as Go string constants with helper functions",
	Parse:     "Generate parsing functions to convert strings into enum values",
	Normalize: "Generate normalization helpers (e.g., case-insensitive matching)",
	JSON:      "Add JSON marshal/unmarshal support for enums",
	SQL:       "Add SQL database scan/value support for enums",
}

var MethodMap = map[Method]MethodFunc{
	String: func(e *Enum, name string, enumType string, values []config.EnumValue) {
		e.String(name, enumType, values)
	},
	Parse: func(e *Enum, name string, enumType string, values []config.EnumValue) {
		e.Parse(name, enumType, values)
	},
	Normalize: func(e *Enum, name string, enumType string, values []config.EnumValue) {
		if enumType != "string" {
			// you can choose to log OR panic
			slog.Info("Normalize only applies to string enums", "enum", name, "has type", enumType)
			return
		}
		e.Normalize(name)
	},
	JSON: func(e *Enum, name string, enumType string, values []config.EnumValue) {
		e.JSON(name)
	},
	SQL: func(e *Enum, name string, enumType string, values []config.EnumValue) {
		e.SQLValueScan(name)
	},
}

type Enum struct {
	f *jen.File
}

func New(packageName string) *Enum {
	return &Enum{
		f: jen.NewFile(packageName),
	}
}

func (e *Enum) HeaderComment(comment ...string) *Enum {
	e.f.HeaderComment("Code generated by enum generate; DO NOT EDIT.")
	for _, c := range comment {
		e.f.HeaderComment(c)
	}
	return e
}

func (e *Enum) ImportName(imports ...ImportName) *Enum {
	for _, imp := range imports {
		for name, alias := range imp {
			e.f.ImportName(name, alias)
		}
	}
	return e
}

func displayValue(v any, fallback any) any {
	if v == nil {
		return fallback
	}
	return v
}

func emptyValue(enumType string) interface{} {
	switch enumType {
	case "string":
		return ""
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64":
		return 0
	case "float32", "float64":
		return 0.0
	default:
		panic("unsupported enum type: " + enumType)
	}
}

func (e *Enum) Method(name, enumType string, values []config.EnumValue, methods ...string) {
	for _, m := range methods {
		if fn, ok := MethodMap[Method(strings.ToLower(m))]; ok {
			fn(e, name, enumType, values)
		} else {
			slog.Info(fmt.Sprintf("don't support method: %v", m))
		}
	}
}

func (e *Enum) Enum(name, enumType string, values []config.EnumValue, methods []string) {
	f := e.f
	f.Type().Id(name).Id(enumType)
	e.Consts(name, enumType, values)
	e.Is(name, values)
	e.Map(name, enumType, values)
	e.Slice(name, enumType, values)
	e.Method(name, enumType, values, methods...)
}

func (e *Enum) JenFile() *jen.File {
	return e.f
}
